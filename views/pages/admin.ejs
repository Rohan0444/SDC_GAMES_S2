<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin Panel - Among Us Game</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #1A1A2E 0%, #16213E 50%, #0F0F23 100%);
      color: #fff;
      overflow-x: hidden;
      background-image: url('/images/among_us_background.svg');
      background-size: cover;
      background-attachment: fixed;
      min-height: 100vh;
    }

    .admin-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .admin-header {
      text-align: center;
      margin-bottom: 40px;
      padding: 20px;
      background: rgba(15, 15, 35, 0.8);
      border-radius: 15px;
      border: 2px solid #FF6B6B;
      backdrop-filter: blur(10px);
    }

    .admin-title {
      font-family: 'Orbitron', monospace;
      font-size: 48px;
      font-weight: 900;
      background: linear-gradient(45deg, #FF6B6B, #FF0000);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
    }

    .admin-subtitle {
      font-size: 18px;
      color: #A0AEC0;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .admin-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 30px;
      margin-bottom: 40px;
    }

    .admin-card {
      background: rgba(15, 15, 35, 0.8);
      border-radius: 15px;
      padding: 30px;
      border: 2px solid rgba(255, 107, 107, 0.3);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .admin-card:hover {
      border-color: #FF6B6B;
      box-shadow: 0 10px 30px rgba(255, 107, 107, 0.2);
    }

    .timer-section {
      background: linear-gradient(45deg, #1A1A2E 0%, #16213E 50%, #0F0F23 100%);
      border: 2px solid rgba(255, 107, 107, 0.3);
      border-radius: 15px;
      padding: 25px;
      margin: 20px 0;
      position: relative;
      overflow: hidden;
    }

    .timer-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('/images/among_us_background.svg') center/cover;
      opacity: 0.1;
      z-index: 0;
    }

    .timer-section > * {
      position: relative;
      z-index: 1;
    }

    .timer-title {
      color: #FF6B6B;
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      text-align: center;
    }

    .timer-display {
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #FF6B6B;
      border-radius: 10px;
      color: #FF6B6B;
      font-size: 24px;
      font-weight: 700;
      padding: 15px;
      text-align: center;
      margin-bottom: 15px;
      font-family: 'Courier New', monospace;
    }

    .timer-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .timer-controls .btn {
      padding: 8px 16px;
      font-size: 14px;
    }

    .card-title {
      font-size: 24px;
      font-weight: 700;
      color: #FF6B6B;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: #E2E8F0;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .form-input {
      width: 100%;
      padding: 12px 16px;
      background: rgba(26, 26, 46, 0.6);
      border: 2px solid rgba(255, 107, 107, 0.3);
      border-radius: 8px;
      color: #fff;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    .form-input:focus {
      outline: none;
      border-color: #FF6B6B;
      box-shadow: 0 0 15px rgba(255, 107, 107, 0.3);
    }

    .form-textarea {
      width: 100%;
      padding: 12px 16px;
      background: rgba(26, 26, 46, 0.6);
      border: 2px solid rgba(255, 107, 107, 0.3);
      border-radius: 8px;
      color: #fff;
      font-size: 16px;
      min-height: 100px;
      resize: vertical;
      transition: all 0.3s ease;
    }

    .form-textarea:focus {
      outline: none;
      border-color: #FF6B6B;
      box-shadow: 0 0 15px rgba(255, 107, 107, 0.3);
    }

    .timer-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .timer-display {
      background: rgba(26, 26, 46, 0.8);
      border: 2px solid #FF6B6B;
      border-radius: 10px;
      padding: 20px;
      text-align: center;
    }

    .timer-value {
      font-family: 'Orbitron', monospace;
      font-size: 32px;
      font-weight: 900;
      color: #FF6B6B;
      margin-bottom: 10px;
    }

    .timer-label {
      font-size: 14px;
      color: #A0AEC0;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn {
      background: linear-gradient(45deg, #FF6B6B, #FF0000);
      border: none;
      color: #fff;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn:hover {
      background: linear-gradient(45deg, #FF0000, #FF6B6B);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
    }

    .btn-secondary {
      background: transparent;
      border: 2px solid #FF6B6B;
      color: #FF6B6B;
    }

    .btn-secondary:hover {
      background: rgba(255, 107, 107, 0.1);
    }

    .btn-group {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-live {
      background: #68D391;
      box-shadow: 0 0 10px rgba(104, 211, 145, 0.6);
    }

    .status-offline {
      background: #FF6B6B;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
    }

    .live-updates {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(15, 15, 35, 0.9);
      border: 2px solid #68D391;
      border-radius: 10px;
      padding: 15px;
      backdrop-filter: blur(10px);
      z-index: 1000;
    }

    .live-status {
      display: flex;
      align-items: center;
      font-size: 14px;
      font-weight: 600;
      color: #68D391;
    }

    .file-upload {
      border: 2px dashed rgba(255, 107, 107, 0.3);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .file-upload:hover {
      border-color: #FF6B6B;
      background: rgba(255, 107, 107, 0.05);
    }

    .file-upload input {
      display: none;
    }

    .upload-text {
      color: #A0AEC0;
      font-size: 14px;
    }

    .attachment-list {
      margin-top: 15px;
    }

    .attachment-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(26, 26, 46, 0.6);
      padding: 10px 15px;
      border-radius: 8px;
      margin-bottom: 10px;
    }

    .attachment-name {
      color: #E2E8F0;
      font-size: 14px;
    }

    .attachment-remove {
      background: #FF6B6B;
      border: none;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .links-list {
      margin-top: 15px;
    }

    .link-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(26, 26, 46, 0.6);
      padding: 10px 15px;
      border-radius: 8px;
      margin-bottom: 10px;
      border: 1px solid rgba(255, 107, 107, 0.3);
    }

    .link-name {
      color: #E2E8F0;
      font-size: 14px;
      font-weight: 600;
      margin-right: 10px;
    }

    .link-url {
      color: #A0AEC0;
      font-size: 12px;
      flex: 1;
      margin-right: 10px;
      word-break: break-all;
    }

    .link-remove {
      background: #FF6B6B;
      border: none;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .link-input-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .link-input-group .form-input {
      flex: 1;
      min-width: 200px;
    }

    @media (max-width: 768px) {
      .admin-grid {
        grid-template-columns: 1fr;
      }
      
      .timer-controls {
        grid-template-columns: 1fr;
      }
      
      .admin-container {
        padding: 10px;
      }

      .link-input-group {
        flex-direction: column;
        align-items: stretch;
      }

      .link-input-group .form-input {
        min-width: auto;
      }

      .btn-group {
        flex-direction: column;
      }

      .form-group {
        margin-bottom: 15px;
      }

      .admin-card {
        padding: 20px;
      }

      .admin-title {
        font-size: 36px;
      }
    }
  </style>
</head>
<body>
  <!-- Live Updates Indicator -->
  <div class="live-updates">
    <div class="live-status">
      <span class="status-indicator status-live"></span>
      LIVE UPDATES
    </div>
  </div>

  <div class="admin-container">
    <!-- Admin Header -->
    <div class="admin-header">
      <h1 class="admin-title">ADMIN PANEL</h1>
      <p class="admin-subtitle">Control the Among Us Game Experience</p>
    </div>

    <div class="admin-grid">
      <!-- Round Control Section -->
      <div class="admin-card">
        <h2 class="card-title">🔹 Round Control Section</h2>
        <p style="color: #A0AEC0; margin-bottom: 20px;">Controls the Let's Begin Page</p>
        
        <div class="form-group">
          <label class="form-label">Round Name</label>
          <input type="text" id="roundName" class="form-input" placeholder="Enter round name..." value="Mission Alpha">
        </div>

        <div class="form-group">
          <label class="form-label">Round Number</label>
          <input type="number" id="roundNumber" class="form-input" placeholder="Enter round number..." min="1" value="1">
        </div>

        <div class="form-group">
          <label class="form-label">Description</label>
          <textarea id="roundDetails" class="form-textarea" placeholder="Enter round description...">Complete all tasks to prepare the spaceship for departure. Work together as a team, but beware of impostors among you!</textarea>
        </div>

        <div class="form-group">
          <label class="form-label">Rules</label>
          <textarea id="roundRules" class="form-textarea" placeholder="Enter round rules...">Follow all instructions carefully. No cheating allowed. Work as a team.</textarea>
        </div>

        <div class="form-group">
          <label class="form-label">Round Links</label>
          <div id="roundLinksContainer">
            <div class="link-input-group">
              <input type="text" class="form-input link-name-input" placeholder="Link name (e.g., x1, x2, x3)" style="margin-bottom: 10px;">
              <input type="text" class="form-input link-url-input" placeholder="Enter URL (e.g., leetcode.com, github.com, etc.)" style="margin-bottom: 10px;">
              <button type="button" class="btn btn-secondary" onclick="addRoundLink()" style="margin-bottom: 10px;">Add Link</button>
            </div>
            <div id="roundLinksList" class="links-list"></div>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">Participation Type</label>
          <select id="participationType" class="form-input">
            <option value="individual">Individual</option>
            <option value="team">Team</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">Duration (in minutes)</label>
          <input type="number" id="roundDuration" class="form-input" placeholder="Enter round duration in minutes..." min="1" max="120" value="5">
        </div>

        <div class="btn-group">
          <button class="btn" onclick="startRound()">Start Round</button>
        </div>
      </div>

      <!-- Eliminate Participants Section -->
      <div class="admin-card">
        <h2 class="card-title">🔹 Eliminate Participants Section</h2>
        <p style="color: #A0AEC0; margin-bottom: 20px;">Controls the Participant Page</p>
        
        <div class="form-group">
          <label class="form-label">Enter Roll Numbers to Eliminate</label>
          <input type="text" id="eliminateRollNumbers" class="form-input" placeholder="Enter roll numbers separated by commas (e.g., 123, 456, 789)">
        </div>

        <div class="form-group">
          <label class="form-label">Enter Team Name to Eliminate</label>
          <input type="text" id="eliminateTeamName" class="form-input" placeholder="Enter team name to eliminate all members...">
        </div>

        <div class="btn-group">
          <button class="btn" onclick="eliminateParticipants()">Eliminate by Roll Numbers</button>
          <button class="btn btn-secondary" onclick="eliminateByTeam()">Eliminate by Team</button>
        </div>

        <div class="form-group" style="margin-top: 20px;">
          <label class="form-label">Current Participants Status</label>
          <div id="participantsStatus" style="background: rgba(26, 26, 46, 0.6); border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 8px; padding: 15px; max-height: 200px; overflow-y: auto;">
            <div style="color: #A0AEC0; font-size: 14px;">Loading participants...</div>
          </div>
        </div>
      </div>

      <!-- Participant Management Section -->
      <div class="admin-card">
        <h2 class="card-title">🔹 Participant Management</h2>
        <p style="color: #A0AEC0; margin-bottom: 20px;">Add and manage participants</p>
        
        <div class="form-group">
          <label class="form-label">Name *</label>
          <input type="text" id="participant-name" class="form-input" placeholder="Enter participant name..." required>
        </div>

        <div class="form-group">
          <label class="form-label">Roll Number *</label>
          <input type="text" id="participant-roll" class="form-input" placeholder="Enter roll number..." required>
        </div>

        <div class="form-group">
          <label class="form-label">Email *</label>
          <input type="email" id="participant-email" class="form-input" placeholder="Enter email..." required>
        </div>

        <div class="form-group">
          <label class="form-label">Phone</label>
          <input type="tel" id="participant-phone" class="form-input" placeholder="Enter phone number...">
        </div>

        <div class="form-group">
          <label class="form-label">Team</label>
          <input type="text" id="participant-team" class="form-input" placeholder="Enter team name (optional)...">
        </div>

        <div class="form-group">
          <label class="form-label">College</label>
          <input type="text" id="participant-college" class="form-input" placeholder="Enter college..." value="NITW">
        </div>

        <div class="form-group">
          <label class="form-label">Branch</label>
          <input type="text" id="participant-branch" class="form-input" placeholder="Enter branch..." value="NULL">
        </div>

        <div class="form-group">
          <label class="form-label">Year</label>
          <input type="text" id="participant-year" class="form-input" placeholder="Enter year..." value="0">
        </div>

        <div class="form-group">
          <label class="form-label">Degree</label>
          <input type="text" id="participant-degree" class="form-input" placeholder="Enter degree..." value="B.Tech">
        </div>

        <div class="form-group">
          <label class="form-label">Avatar</label>
          <select id="participant-avatar" class="form-input">
            <option value="blue.png">Blue</option>
            <option value="green.png">Green</option>
            <option value="red.png">Red</option>
            <option value="yellow.png">Yellow</option>
            <option value="purple.png">Purple</option>
            <option value="cyan.png">Cyan</option>
            <option value="white.png">White</option>
            <option value="black.png">Black</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">Status</label>
          <select id="participant-status" class="form-input">
            <option value="Alive">Alive</option>
            <option value="Eliminated">Eliminated</option>
          </select>
        </div>

        <div class="btn-group">
          <button class="btn" onclick="addParticipant()">Add Participant</button>
          <button class="btn btn-secondary" onclick="clearParticipantForm()">Clear Form</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game state - will be loaded from database
    let gameState = {
      roundNumber: 1,
      roundName: 'Mission Alpha',
      roundDetails: 'Complete all tasks to prepare the spaceship for departure. Work together as a team, but beware of impostors among you!',
      preRoundMinutes: 5,
      roundDuration: 5,
      currentTimer: 300, // 5 minutes in seconds
      isActive: false,
      attachments: [],
      links: [],
      roundLinks: [],
      preGameCountdown: {
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        isActive: false,
        isPaused: false
      },
      gameStatus: 'waiting',
      countdownFinished: false,
      currentRoundStarted: false
    };

    // Load game settings from database
    async function loadGameSettings() {
      try {
        const response = await fetch('/api/game-state');
        if (response.ok) {
          const serverState = await response.json();
          gameState = { ...gameState, ...serverState };
          updateDisplay();
          updatePreGameTimerDisplay();
          updateNextRoundAttachments();
          updateGameStatusDisplay();
          updateUIState();
        }
      } catch (error) {
        console.error('Error loading game settings:', error);
      }
    }

    // Update UI state based on game status
    function updateUIState() {
      console.log('Updating UI state:', {
        gameStatus: gameState.gameStatus,
        countdownFinished: gameState.countdownFinished,
        currentRoundStarted: gameState.currentRoundStarted,
        countdownActive: gameState.preGameCountdown?.isActive
      });
      
      // Update form fields with current state
      document.getElementById('roundNumber').value = gameState.roundNumber || 1;
      document.getElementById('roundName').value = gameState.roundName || 'Mission Alpha';
      document.getElementById('roundDetails').value = gameState.roundDetails || '';
      document.getElementById('preRoundMinutes').value = gameState.preRoundMinutes || 5;
      document.getElementById('roundDuration').value = gameState.roundDuration || 5;
      
      // Update attachments display
      updateAttachments();
      
      // Update round links display
      updateRoundLinksDisplay();
    }

    // Save game settings to database
    async function saveGameSettings() {
      try {
        const response = await fetch('/api/game-settings', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(gameState)
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          showNotification('Settings saved successfully!');
        } else {
          showNotification('Error saving settings!');
        }
      } catch (error) {
        console.error('Error saving game settings:', error);
        showNotification('Error saving settings!');
      }
    }

    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
      loadGameSettings();
      loadParticipantsStatus();
      startLiveUpdates();
    });

    // Pre-game countdown functions
    async function setPreGameTimer(days, hours, minutes, seconds) {
      try {
        const response = await fetch('/api/countdown', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            days: days,
            hours: hours,
            minutes: minutes,
            seconds: seconds,
            isActive: false,
            isPaused: false
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updatePreGameTimerDisplay();
          showNotification('Countdown timer set!');
        } else {
          showNotification('Error setting countdown timer!');
        }
      } catch (error) {
        console.error('Error setting countdown timer:', error);
        showNotification('Error setting countdown timer!');
      }
    }

    function setCustomPreGameTimer() {
      const days = parseInt(document.getElementById('customDays').value) || 0;
      const hours = parseInt(document.getElementById('customHours').value) || 0;
      const minutes = parseInt(document.getElementById('customMinutes').value) || 0;
      const seconds = parseInt(document.getElementById('customSeconds').value) || 0;
      setPreGameTimer(days, hours, minutes, seconds);
    }

    async function startPreGameCountdown() {
      try {
        console.log('Starting pre-game countdown with:', gameState.preGameCountdown);
        const response = await fetch('/api/countdown', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            days: gameState.preGameCountdown.days,
            hours: gameState.preGameCountdown.hours,
            minutes: gameState.preGameCountdown.minutes,
            seconds: gameState.preGameCountdown.seconds,
            isActive: true,
            isPaused: false
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateUIState();
          showNotification('Pre-game countdown started!');
        } else {
          showNotification('Error starting countdown!');
        }
      } catch (error) {
        console.error('Error starting countdown:', error);
        showNotification('Error starting countdown!');
      }
    }

    async function pausePreGameCountdown() {
      gameState.preGameCountdown.isPaused = !gameState.preGameCountdown.isPaused;
      await saveGameSettings();
      showNotification(gameState.preGameCountdown.isPaused ? 'Countdown paused!' : 'Countdown resumed!');
    }

    async function resetPreGameCountdown() {
      gameState.preGameCountdown.days = 0;
      gameState.preGameCountdown.hours = 0;
      gameState.preGameCountdown.minutes = 0;
      gameState.preGameCountdown.seconds = 0;
      gameState.preGameCountdown.isActive = false;
      gameState.preGameCountdown.isPaused = false;
      updatePreGameTimerDisplay();
      await saveGameSettings();
      showNotification('Pre-game countdown reset!');
    }

    function updatePreGameTimerDisplay() {
      // Use countdown status from server if available
      if (gameState.countdownStatus) {
        const timer = gameState.countdownStatus;
        const display = `${timer.days.toString().padStart(2, '0')}:${timer.hours.toString().padStart(2, '0')}:${timer.minutes.toString().padStart(2, '0')}:${timer.seconds.toString().padStart(2, '0')}`;
        document.getElementById('preGameTimer').textContent = display;
      } else {
        // Fallback to local state
        const timer = gameState.preGameCountdown;
        const display = `${timer.days.toString().padStart(2, '0')}:${timer.hours.toString().padStart(2, '0')}:${timer.minutes.toString().padStart(2, '0')}:${timer.seconds.toString().padStart(2, '0')}`;
        document.getElementById('preGameTimer').textContent = display;
      }
    }


    // Update game status display
    function updateGameStatusDisplay() {
      const statusIndicator = document.getElementById('gameStatusIndicator');
      const statusText = document.getElementById('gameStatusText');
      const currentRoundDisplay = document.getElementById('currentRoundDisplay');
      const liveRoundTimer = document.getElementById('liveRoundTimer');
      
      if (statusIndicator && statusText) {
        if (gameState.gameStatus === 'active') {
          statusIndicator.className = 'status-indicator status-live';
          statusText.textContent = 'Game Active';
          statusText.style.color = '#68D391';
        } else if (gameState.gameStatus === 'countdown') {
          statusIndicator.className = 'status-indicator status-live';
          statusText.textContent = 'Countdown Active';
          statusText.style.color = '#FFD700';
        } else {
          statusIndicator.className = 'status-indicator status-offline';
          statusText.textContent = 'Game Waiting';
          statusText.style.color = '#FF6B6B';
        }
      }
      
      if (currentRoundDisplay) {
        currentRoundDisplay.textContent = gameState.roundName || 'Mission Alpha';
      }
      
      if (liveRoundTimer) {
        const minutes = Math.floor(gameState.currentTimer / 60);
        const seconds = gameState.currentTimer % 60;
        liveRoundTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }

    // Update timer display
    function updateTimerDisplay() {
      const currentMinutes = Math.floor(gameState.currentTimer / 60);
      const currentSeconds = gameState.currentTimer % 60;
      const nextMinutes = Math.floor(gameState.nextTimer / 60);
      const nextSeconds = gameState.nextTimer % 60;

      const currentTimerElement = document.getElementById('currentTimerDisplay');
      const nextTimerElement = document.getElementById('nextTimerDisplay');
      
      if (currentTimerElement) {
        currentTimerElement.textContent = 
          `${currentMinutes.toString().padStart(2, '0')}:${currentSeconds.toString().padStart(2, '0')}`;
      }
      
      if (nextTimerElement) {
        nextTimerElement.textContent = 
          `${nextMinutes.toString().padStart(2, '0')}:${nextSeconds.toString().padStart(2, '0')}`;
      }
    }

    // Set current timer
    async function setCurrentTimer(minutes) {
      try {
        const response = await fetch('/api/timers', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            currentTimer: minutes * 60,
            nextTimer: gameState.nextTimer
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateTimerDisplay();
          showNotification(`Current round timer set to ${minutes} minutes`);
        } else {
          showNotification('Error setting current timer!');
        }
      } catch (error) {
        console.error('Error setting current timer:', error);
        showNotification('Error setting current timer!');
      }
    }

    // Set next timer
    async function setNextTimer(minutes) {
      try {
        const response = await fetch('/api/timers', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            currentTimer: gameState.currentTimer,
            nextTimer: minutes * 60
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateTimerDisplay();
          showNotification(`Next round timer set to ${minutes} minutes`);
        } else {
          showNotification('Error setting next timer!');
        }
      } catch (error) {
        console.error('Error setting next timer:', error);
        showNotification('Error setting next timer!');
      }
    }

    // Set custom current timer
    async function setCustomCurrentTimer() {
      const minutes = parseInt(document.getElementById('customCurrentTimer').value) || 5;
      await setCurrentTimer(minutes);
    }

    // Set custom next timer
    async function setCustomNextTimer() {
      const minutes = parseInt(document.getElementById('customNextTimer').value) || 3;
      await setNextTimer(minutes);
    }

    // Update round information
    async function updateRound() {
      gameState.roundName = document.getElementById('roundName').value;
      gameState.roundDetails = document.getElementById('roundDetails').value;
      await saveGameSettings();
      showNotification('Round updated successfully!');
    }

    // Round links management
    function addRoundLink() {
      const nameInput = document.querySelector('.link-name-input');
      const urlInput = document.querySelector('.link-url-input');
      const name = nameInput.value.trim();
      const url = urlInput.value.trim();
      
      if (!name || !url) {
        showNotification('Please enter both link name and URL!');
        return;
      }
      
      // Validate URL
      try {
        const fullUrl = url.startsWith('http') ? url : `https://${url}`;
        new URL(fullUrl);
      } catch (e) {
        showNotification('Please enter a valid URL!');
        return;
      }
      
      // Add to gameState
      if (!gameState.roundLinks) {
        gameState.roundLinks = [];
      }
      
      gameState.roundLinks.push({
        name: name,
        url: url.startsWith('http') ? url : `https://${url}`
      });
      
      // Clear inputs
      nameInput.value = '';
      urlInput.value = '';
      
      // Update display
      updateRoundLinksDisplay();
      showNotification('Link added successfully!');
    }
    
    function removeRoundLink(index) {
      gameState.roundLinks.splice(index, 1);
      updateRoundLinksDisplay();
    }
    
    function updateRoundLinksDisplay() {
      const linksList = document.getElementById('roundLinksList');
      linksList.innerHTML = '';
      
      if (!gameState.roundLinks || gameState.roundLinks.length === 0) {
        linksList.innerHTML = '<div style="color: #A0AEC0; font-size: 14px; text-align: center; padding: 20px;">No links added yet</div>';
        return;
      }
      
      gameState.roundLinks.forEach((link, index) => {
        const linkItem = document.createElement('div');
        linkItem.className = 'link-item';
        linkItem.innerHTML = `
          <span class="link-name">${link.name}</span>
          <span class="link-url">${link.url}</span>
          <button class="link-remove" onclick="removeRoundLink(${index})">Remove</button>
        `;
        linksList.appendChild(linkItem);
      });
    }

    // Start round with round details
    async function startRound() {
      const roundNumber = parseInt(document.getElementById('roundNumber').value) || 1;
      const roundName = document.getElementById('roundName').value;
      const roundDetails = document.getElementById('roundDetails').value;
      const roundRules = document.getElementById('roundRules').value;
      const participationType = document.getElementById('participationType').value;
      const roundDuration = parseInt(document.getElementById('roundDuration').value) || 5;
      
      if (!roundName || !roundDetails) {
        showNotification('Please fill in round name and description!');
        return;
      }
      
      try {
        // Prepare round data
        const roundData = {
          roundNumber: roundNumber,
          roundName: roundName,
          roundDetails: roundDetails,
          roundRules: roundRules,
          roundUrl: '', // Keep for backward compatibility
          roundLinks: gameState.roundLinks || [],
          participationType: participationType,
          roundDuration: roundDuration,
          attachments: [], // No more attachments
          duration: roundDuration * 60 // Convert to seconds
        };
        
        // Call API to start round
        const response = await fetch('/api/start-round', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(roundData)
        });
        
        if (response.ok) {
          const result = await response.json();
          gameState = { ...gameState, ...result };
          updateUIState();
          showNotification(`Round ${roundNumber} started! Duration: ${roundDuration} minutes.`);
          
                  // Clear form after successful start
                  document.getElementById('roundName').value = '';
                  document.getElementById('roundDetails').value = '';
                  document.getElementById('roundRules').value = '';
                  document.getElementById('roundUrl').value = '';
                  document.getElementById('participationType').value = 'individual';
                  document.getElementById('roundNumber').value = parseInt(document.getElementById('roundNumber').value) + 1;
        } else {
          showNotification('Error starting round!');
        }
      } catch (error) {
        console.error('Error starting round:', error);
        showNotification('Error starting round!');
      }
    }

    // Clear round
    async function clearRound() {
      document.getElementById('roundName').value = '';
      document.getElementById('roundDetails').value = '';
      gameState.roundName = '';
      gameState.roundDetails = '';
      await saveGameSettings();
      showNotification('Round cleared!');
    }

    // File upload handling
    document.getElementById('fileInput').addEventListener('change', async function(e) {
      const files = Array.from(e.target.files);
      files.forEach(file => {
        gameState.attachments.push({
          name: file.name,
          type: file.type,
          size: file.size,
          url: URL.createObjectURL(file),
          isLink: false
        });
      });
      updateAttachments();
    });

    // Next round file upload handling
    document.getElementById('nextFileInput').addEventListener('change', async function(e) {
      const files = Array.from(e.target.files);
      files.forEach(file => {
        gameState.nextRound.attachments.push({
          name: file.name,
          type: file.type,
          size: file.size,
          url: URL.createObjectURL(file),
          isLink: false
        });
      });
      updateNextRoundAttachments();
      await saveGameSettings();
    });

    // Add link function
    async function addLink() {
      const url = document.getElementById('linkUrl').value;
      const name = document.getElementById('linkName').value;
      
      if (url && name) {
        // Validate URL
        try {
          new URL(url);
        } catch (e) {
          showNotification('Please enter a valid URL!');
          return;
        }
        
        gameState.attachments.push({
          name: name,
          url: url,
          isLink: true
        });
        updateAttachments();
        await saveGameSettings();
        
        // Clear inputs
        document.getElementById('linkUrl').value = '';
        document.getElementById('linkName').value = '';
        showNotification('Link added successfully!');
      } else {
        showNotification('Please enter both URL and name!');
      }
    }

    // Add next round link function
    async function addNextRoundLink() {
      const url = document.getElementById('nextLinkUrl').value;
      const name = document.getElementById('nextLinkName').value;
      
      if (url && name) {
        // Validate URL
        try {
          new URL(url);
        } catch (e) {
          showNotification('Please enter a valid URL!');
          return;
        }
        
        gameState.nextRound.attachments.push({
          name: name,
          url: url,
          isLink: true
        });
        updateNextRoundAttachments();
        await saveGameSettings();
        
        // Clear inputs
        document.getElementById('nextLinkUrl').value = '';
        document.getElementById('nextLinkName').value = '';
        showNotification('Next round link added successfully!');
      } else {
        showNotification('Please enter both URL and name!');
      }
    }

    // Update next round
    async function updateNextRound() {
      gameState.nextRound.name = document.getElementById('nextRoundName').value;
      gameState.nextRound.details = document.getElementById('nextRoundDetails').value;
      await saveGameSettings();
      showNotification('Next round updated successfully!');
    }

    // Update current round
    async function updateCurrentRound() {
      const roundName = document.getElementById('updateRoundName').value;
      const roundDetails = document.getElementById('updateRoundDetails').value;
      const roundDuration = parseInt(document.getElementById('updateRoundDuration').value);
      
      if (!roundName || !roundDetails) {
        showNotification('Please fill in round name and details!');
        return;
      }
      
      try {
        const response = await fetch('/api/update-current-round', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            roundName: roundName,
            roundDetails: roundDetails,
            currentTimer: roundDuration ? roundDuration * 60 : undefined,
            attachments: gameState.attachments
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateDisplay();
          updateUIState();
          showNotification('Current round updated successfully!');
          
          // Clear form
          document.getElementById('updateRoundName').value = '';
          document.getElementById('updateRoundDetails').value = '';
          document.getElementById('updateRoundDuration').value = '';
        } else {
          showNotification('Error updating current round!');
        }
      } catch (error) {
        console.error('Error updating current round:', error);
        showNotification('Error updating current round!');
      }
    }

    // Start next round early
    async function startNextRoundEarly() {
      try {
        const response = await fetch('/api/start-next-round-early', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateDisplay();
          updateNextRoundAttachments();
          updateUIState();
          showNotification('Next round started early!');
        } else {
          showNotification('Error starting next round early!');
        }
      } catch (error) {
        console.error('Error starting next round early:', error);
        showNotification('Error starting next round early!');
      }
    }

    // Start next round
    async function startNextRound() {
      const nextRoundName = document.getElementById('nextRoundName').value;
      const nextRoundDetails = document.getElementById('nextRoundDetails').value;
      const nextRoundDuration = parseInt(document.getElementById('nextRoundDuration').value) || 3;
      
      if (!nextRoundName || !nextRoundDetails) {
        showNotification('Please fill in next round name and details!');
        return;
      }
      
      try {
        // Move next round to current round
        gameState.roundName = nextRoundName;
        gameState.roundDetails = nextRoundDetails;
        gameState.currentTimer = nextRoundDuration * 60; // Convert to seconds
        gameState.roundStartTime = new Date();
        gameState.currentRound += 1;
        
        // Reset next round
        gameState.nextRound.name = 'Mission Beta';
        gameState.nextRound.details = 'New challenges await! Complete the reactor tasks and identify the impostor before time runs out.';
        gameState.nextRound.attachments = [];
        
        await saveGameSettings();
        updateDisplay();
        updateNextRoundAttachments();
        updateUIState();
        showNotification('Next round started!');
      } catch (error) {
        console.error('Error starting next round:', error);
        showNotification('Error starting next round!');
      }
    }

    // Update attachments display
    function updateAttachments() {
      const attachmentList = document.getElementById('attachmentList');
      attachmentList.innerHTML = '';
      
      gameState.attachments.forEach((attachment, index) => {
        const item = document.createElement('div');
        item.className = 'attachment-item';
        const linkIcon = attachment.isLink ? '🔗' : '📎';
        item.innerHTML = `
          <span class="attachment-name">${linkIcon} ${attachment.name}</span>
          <button class="attachment-remove" onclick="removeAttachment(${index})">Remove</button>
        `;
        attachmentList.appendChild(item);
      });
    }

    // Update next round attachments display
    function updateNextRoundAttachments() {
      const attachmentList = document.getElementById('nextRoundAttachmentList');
      attachmentList.innerHTML = '';
      
      gameState.nextRound.attachments.forEach((attachment, index) => {
        const item = document.createElement('div');
        item.className = 'attachment-item';
        const linkIcon = attachment.isLink ? '🔗' : '📎';
        item.innerHTML = `
          <span class="attachment-name">${linkIcon} ${attachment.name}</span>
          <button class="attachment-remove" onclick="removeNextRoundAttachment(${index})">Remove</button>
        `;
        attachmentList.appendChild(item);
      });
    }

    // Remove attachment
    async function removeAttachment(index) {
      gameState.attachments.splice(index, 1);
      updateAttachments();
      await saveGameSettings();
    }

    // Remove next round attachment
    async function removeNextRoundAttachment(index) {
      gameState.nextRound.attachments.splice(index, 1);
      updateNextRoundAttachments();
      await saveGameSettings();
    }

    // Game control functions
    async function startGame() {
      try {
        const response = await fetch('/api/game-action', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            action: 'start_game',
            details: 'Game started by admin'
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          showNotification('Game started!');
        } else {
          showNotification('Error starting game!');
        }
      } catch (error) {
        console.error('Error starting game:', error);
        showNotification('Error starting game!');
      }
    }

    async function pauseGame() {
      try {
        const response = await fetch('/api/game-action', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            action: 'pause_game',
            details: 'Game paused by admin'
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          showNotification('Game paused!');
        } else {
          showNotification('Error pausing game!');
        }
      } catch (error) {
        console.error('Error pausing game:', error);
        showNotification('Error pausing game!');
      }
    }

    async function resetGame() {
      try {
        const response = await fetch('/api/game-action', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            action: 'reset_game',
            details: 'Game reset by admin'
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateDisplay();
          showNotification('Game reset!');
        } else {
          showNotification('Error resetting game!');
        }
      } catch (error) {
        console.error('Error resetting game:', error);
        showNotification('Error resetting game!');
      }
    }

    // Eliminate participants by roll numbers
    async function eliminateParticipants() {
      const rollNumbersInput = document.getElementById('eliminateRollNumbers').value.trim();
      
      if (!rollNumbersInput) {
        showNotification('Please enter roll numbers to eliminate!');
        return;
      }
      
      try {
        // Parse roll numbers (comma-separated)
        const rollNumbers = rollNumbersInput.split(',').map(roll => roll.trim()).filter(roll => roll);
        
        if (rollNumbers.length === 0) {
          showNotification('Please enter valid roll numbers!');
          return;
        }
        
        // Call API to eliminate participants
        const response = await fetch('/api/eliminate-participants', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ rollNumbers })
        });
        
        if (response.ok) {
          const result = await response.json();
          showNotification(`Successfully eliminated ${result.eliminatedCount} participants!`);
          document.getElementById('eliminateRollNumbers').value = '';
          loadParticipantsStatus();
        } else {
          showNotification('Error eliminating participants!');
        }
      } catch (error) {
        console.error('Error eliminating participants:', error);
        showNotification('Error eliminating participants!');
      }
    }

    // Load participants status
    async function loadParticipantsStatus() {
      try {
        const response = await fetch('/api/participants-status');
        if (response.ok) {
          const participants = await response.json();
          updateParticipantsStatus(participants);
        }
      } catch (error) {
        console.error('Error loading participants status:', error);
      }
    }

    // Update participants status display
    function updateParticipantsStatus(participants) {
      const statusContainer = document.getElementById('participantsStatus');
      statusContainer.innerHTML = '';
      
      if (participants.length === 0) {
        statusContainer.innerHTML = '<div style="color: #A0AEC0; font-size: 14px;">No participants found</div>';
        return;
      }
      
      participants.forEach(participant => {
        const participantDiv = document.createElement('div');
        participantDiv.style.cssText = `
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 8px 12px;
          margin: 4px 0;
          background: ${participant.status === 'Eliminated' ? 'rgba(255, 107, 107, 0.1)' : 'rgba(104, 211, 145, 0.1)'};
          border: 1px solid ${participant.status === 'Eliminated' ? 'rgba(255, 107, 107, 0.3)' : 'rgba(104, 211, 145, 0.3)'};
          border-radius: 6px;
          font-size: 14px;
        `;
        
        participantDiv.innerHTML = `
          <span style="color: #E2E8F0;">${participant.name} (${participant.rollNumber})</span>
          <span style="color: ${participant.status === 'Eliminated' ? '#FF6B6B' : '#68D391'}; font-weight: 600;">
            ${participant.status}
          </span>
        `;
        
        statusContainer.appendChild(participantDiv);
      });
    }

    // Participant Management Functions
    async function addParticipant() {
      const participantData = {
        name: document.getElementById('participant-name').value.trim(),
        rollNumber: document.getElementById('participant-roll').value.trim(),
        email: document.getElementById('participant-email').value.trim(),
        phone: document.getElementById('participant-phone').value.trim(),
        team: document.getElementById('participant-team').value.trim(),
        college: document.getElementById('participant-college').value.trim(),
        branch: document.getElementById('participant-branch').value.trim(),
        year: document.getElementById('participant-year').value.trim(),
        degree: document.getElementById('participant-degree').value.trim(),
        avatar: document.getElementById('participant-avatar').value,
        status: document.getElementById('participant-status').value
      };

      // Validate required fields
      const requiredFields = ['name', 'rollNumber', 'email'];
      for (const field of requiredFields) {
        if (!participantData[field]) {
          showNotification(`Please fill in ${field}!`);
          return;
        }
      }

      try {
        const response = await fetch('/api/add-participant', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(participantData)
        });

        if (response.ok) {
          const result = await response.json();
          showNotification(`Participant ${participantData.name} added successfully!`);
          clearParticipantForm();
          loadParticipantsStatus(); // Refresh participants list
        } else {
          const errorData = await response.json();
          showNotification(`Error: ${errorData.error}`);
        }
      } catch (error) {
        console.error('Error adding participant:', error);
        showNotification('Error adding participant!');
      }
    }

    // Eliminate participants by team name
    async function eliminateByTeam() {
      const teamName = document.getElementById('eliminateTeamName').value.trim();
      
      if (!teamName) {
        showNotification('Please enter team name to eliminate!');
        return;
      }
      
      try {
        // Call API to eliminate participants by team
        const response = await fetch('/api/eliminate-by-team', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ teamName })
        });
        
        if (response.ok) {
          const result = await response.json();
          showNotification(`Successfully eliminated ${result.eliminatedCount} participants from team "${teamName}"!`);
          document.getElementById('eliminateTeamName').value = '';
          loadParticipantsStatus();
        } else {
          showNotification('Error eliminating participants by team!');
        }
      } catch (error) {
        console.error('Error eliminating participants by team:', error);
        showNotification('Error eliminating participants by team!');
      }
    }

    function clearParticipantForm() {
      document.getElementById('participant-name').value = '';
      document.getElementById('participant-roll').value = '';
      document.getElementById('participant-email').value = '';
      document.getElementById('participant-phone').value = '';
      document.getElementById('participant-team').value = '';
      document.getElementById('participant-college').value = 'NITW';
      document.getElementById('participant-branch').value = 'CSE';
      document.getElementById('participant-year').value = '3rd';
      document.getElementById('participant-degree').value = 'B.Tech';
      document.getElementById('participant-avatar').value = 'blue.png';
      document.getElementById('participant-status').value = 'Alive';
    }

    function viewGame() {
      window.open('/lets-begin', '_blank');
    }

    function viewParticipants() {
      window.open('/participants', '_blank');
    }

    function emergencyMeeting() {
      showNotification('Emergency meeting called!');
    }

    function triggerSabotage() {
      showNotification('Sabotage triggered!');
    }

    function eliminatePlayer() {
      showNotification('Player eliminated!');
    }

    function revealImpostor() {
      showNotification('Impostor revealed!');
    }

    async function endGame() {
      try {
        const response = await fetch('/api/game-action', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            action: 'end_game',
            details: 'Game ended by admin'
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateUIState();
          showNotification('Game ended! All settings reset.');
        } else {
          showNotification('Error ending game!');
        }
      } catch (error) {
        console.error('Error ending game:', error);
        showNotification('Error ending game!');
      }
    }

    // Cooldown functions
    async function setCooldown() {
      const minutes = parseInt(document.getElementById('cooldownMinutes').value) || 5;
      const cooldownEndTime = new Date(Date.now() + (minutes * 60 * 1000));
      
      try {
        const response = await fetch('/api/game-settings', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            cooldownEndTime: cooldownEndTime
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateCooldownStatus();
          showNotification(`Cooldown set for ${minutes} minutes!`);
        } else {
          showNotification('Error setting cooldown!');
        }
      } catch (error) {
        console.error('Error setting cooldown:', error);
        showNotification('Error setting cooldown!');
      }
    }

    async function clearCooldown() {
      try {
        const response = await fetch('/api/game-settings', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            cooldownEndTime: null
          })
        });
        
        if (response.ok) {
          const updatedSettings = await response.json();
          gameState = updatedSettings;
          updateCooldownStatus();
          showNotification('Cooldown cleared!');
        } else {
          showNotification('Error clearing cooldown!');
        }
      } catch (error) {
        console.error('Error clearing cooldown:', error);
        showNotification('Error clearing cooldown!');
      }
    }

    function updateCooldownStatus() {
      const statusElement = document.getElementById('cooldownStatus');
      if (!statusElement) return;
      
      if (gameState.cooldownEndTime) {
        const now = new Date();
        const cooldownEnd = new Date(gameState.cooldownEndTime);
        
        if (now < cooldownEnd) {
          const remaining = Math.floor((cooldownEnd - now) / 1000);
          const minutes = Math.floor(remaining / 60);
          const seconds = remaining % 60;
          statusElement.textContent = `Cooldown active: ${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
          statusElement.style.color = '#FF6B6B';
        } else {
          statusElement.textContent = 'No active cooldown';
          statusElement.style.color = '#68D391';
        }
      } else {
        statusElement.textContent = 'No active cooldown';
        statusElement.style.color = '#68D391';
      }
    }

    // Show notification
    function showNotification(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(45deg, #FF6B6B, #FF0000);
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        font-weight: 600;
        z-index: 10000;
        animation: slideDown 0.3s ease-out;
      `;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }
    function startLiveUpdates() {
      setInterval(async () => {
        // Fetch comprehensive game state from server
        try {
          const response = await fetch('/api/game-state');
          if (response.ok) {
            const serverState = await response.json();
            
            // Update local state
            gameState = { ...gameState, ...serverState };
            
            // Update UI components
            updatePreGameTimerDisplay();
            updateGameStatusDisplay();
            updateCooldownStatus();
            updateUIState();
            
            // Update round timer display
            const liveRoundTimer = document.getElementById('liveRoundTimer');
            if (liveRoundTimer && serverState.roundTimer) {
              liveRoundTimer.textContent = serverState.roundTimer.display;
            }
          }
        } catch (error) {
          console.error('Error fetching game state:', error);
        }
      }, 1000);
      
      // Update participants status every 5 seconds
      setInterval(loadParticipantsStatus, 5000);
    }

    // Show notification
    function showNotification(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(45deg, #FF6B6B, #FF0000);
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        font-weight: 600;
        z-index: 10000;
        animation: slideDown 0.3s ease-out;
      `;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    // Add CSS for notification animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideDown {
        0% { transform: translateX(-50%) translateY(-100%); opacity: 0; }
        100% { transform: translateX(-50%) translateY(0); opacity: 1; }
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>
